package dnsmasq

import (
	"bufio"
	"io/ioutil"
	"log"
	"net"
	"os"
	"os/exec"
	"syscall"

	"github.com/fsnotify/fsnotify"
)

const DNSMasqHeaderConfig = `# dnsmasq.conf file for docker-dnsmasq
# DO NOT EDIT THIS FILE BY HAND, IT IS GENERATED BY docker-dnsmasq
# 
# This file is **removed** when docker-dnsmasq is stopped, and when
# docker containers start or stop.
`

var (
	docker0           = ""                                                         // doker interfaces name
	TempDir           = ""                                                         // temporary directory
	resolveDnsmasq    = "/etc/systemd/resolved.conf.d/docker-domains-dnsmasq.conf" // systemd-resolved config file
	stopDnsmasq       = make(chan int, 0)                                          // channel to reload (1) or stop (2) dnsmasq
	dnsmasqTerminated = make(chan int, 0)                                          // channel to signal that dnsmasq is terminated
	stopRestart       = make(chan int, 0)                                          // channel to stop the goroutine that reloads dnsmasq
)

func Initialize() {
	docker0 = os.Getenv("DOCKER_INTERFACE")
	if docker0 == "" {
		docker0 = "docker0"
	}
	// create a temporary directory
	var err error
	TempDir, err = ioutil.TempDir("", "docker-dnsmasq-")
	log.Println(TempDir)
	if err != nil {
		log.Fatal(err)
	}
	// set the directory to be readable for all
	err = os.Chmod(TempDir, 0755)
	if err != nil {
		log.Fatal(err)
	}

	// TempDir = "/tmp"
}

// Start the dnsmasq daemon that is reloaded on file changes.
func Start() {
	// on FS changed in TempDir, stop dnsmasq and restart it
	startDNSMasq()
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}

	// now...
	// watch the TempDir, if someth changed so we stop dnsmasq and restart it
	go func() {
		for {
			select {
			case <-stopRestart:
				stopDnsmasq <- 2
				return
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}
				log.Println("event:", event)
				if event.Op&fsnotify.Write == fsnotify.Write {
					log.Println("modified file:", event.Name, "restarting dnsmasq")
					stopDnsmasq <- 1
					<-dnsmasqTerminated
					startDNSMasq()
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}
				log.Println("error:", err)
			}
		}
	}()

	err = watcher.Add(TempDir)
	if err != nil {
		log.Fatal(err)
	}

	// need to restart systemd-resolved
	ReloadResolved()
}

// Stop the dnsmasq daemon.
func Stop() {
	stopRestart <- 1
}

// Start dnsmasq and returns:
// - a channel that is closed when dnsmasq is stopped
// - a channel that is closed when dnsmasq is ready to be restarted
func startDNSMasq() {

	// start a dnsmasq instance
	log.Println("Starting dnsmasq")
	c := exec.Command(
		"dnsmasq",
		"-k",
		"--user=root",
		"--conf-file="+TempDir+"/dnsmasq.conf",
		"--proxy-dnssec",
		"--no-resolv",
		"--interface="+docker0,
		"--bind-interfaces",
		"--no-hosts",
	)
	log.Println(c.String())

	// get continuous output
	stdout, err := c.StdoutPipe()
	if err != nil {
		log.Println(err)
	}
	stderr, err := c.StderrPipe()
	if err != nil {
		log.Println(err)
	}

	// start a goroutine to read STDERR
	go func() {
		// read the stderr
		scanner := bufio.NewScanner(stderr)
		for scanner.Scan() {
			log.Println(scanner.Text())
		}
	}()

	// start a goroutine to read STDOUT
	go func() {
		// read the output
		scanner := bufio.NewScanner(stdout)
		for scanner.Scan() {
			log.Println(scanner.Text())
		}
	}()

	// start the command and stop it if the stop channel is closed
	go func() {
		level := <-stopDnsmasq
		log.Println("Stopping dnsmasq")
		c.Process.Signal(os.Signal(syscall.SIGTERM))
		c.Wait()
		//c.Process.Kill()
		log.Println("dnsmasq stopped")
		if level < 2 {
			dnsmasqTerminated <- 1
		} else {
			log.Println("Quitting reload dnsmasq loop")
		}
	}()

	// start the process
	if err := c.Start(); err != nil {
		log.Println(err)
	}

	// refresh the cache now
	RefreshCache()
}

// return the docker interface IP address.
func getDockerIP() string {

	// get IP of docker0 interface
	ip, err := net.InterfaceByName(docker0)
	if err != nil {
		panic(err)
	}
	addr, err := ip.Addrs()
	if err != nil {
		panic(err)
	}
	// get the first IP address
	ipaddr := addr[0].(*net.IPNet).IP.String()
	return ipaddr
}
